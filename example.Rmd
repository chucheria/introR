---
title: "Managing and Exploring Many Models using `tidyr`, `purrr` and `broom`"
output:
  html_document:
    fig_height: 6
    fig_width: 8
    messages: no
    toc: true
    toc_depth: 3
    df_print: paged
---

```{R}
library(tidyverse)
library(broom)
```

## 1. Introduction

There are two main ways of working in R:

- Base way
- "Tidy" way

The base R has been around for decades now, it was made by statistians and software programmers for statistians. R is the evolution of S, a statistical programming language. It has some S legacy (less and less every update) and didn't count for the "new data science" since this field, even being statistics and algebra, it is a pretty new field.

[https://www.tidyverse.org/](Tidyverse) is an opinionated collection of packages design for data science. They all - except ggplot2 - follow the same grammar and allow for mixing and matching, working pretty well together.

Some criticism:

Even with all the advantages we have with this bundle of packages in my experience working with big datasets and the tidyverse can be slow, so that's why I recommend it for exploration and testing models. I'm sure the 98% of the times you are working with data you will be safe, it is not like we are managing big datasets or big data everyday.

In this workshop we are tackling data _the tidy way_, some functional programming will allow us to manage and explore many models at once. This goes beyond the usual exploration - modelling to use modelling as a form of data exploration. 

You could argue that a model (almost by definition) is close to your initial assumptions, that's why the exploration step is done. Here we are going to use modelling to learn about the data, not only predictions but behavior of different groups of data within a dataset.

The outline of this exercise is to create a dataframe where there's one row per group an all data associated with that group is stored in a _column of dataframes_. Then, one can apply modelling techniques to each group and use the output to learn about each group.

## 1. Wikipedia Data - a first look

First, I'll need to load the data, and reshape it so that it's easier to work with. 

#### 1.1 Loading data

```{R}
set.seed(42)
# Training data
data <- read_csv(file = "data/clean.csv") %>% 
  sample_frac(0.5)
```

#### 1.2 Making the data Tidy

At first glance of the data:

```{R}
head(data)
```


We can see that each row contains the name of the Wikipedia article under the `Page` column, the language of the article in the `language` column, the `domain`, and the remaining columns are page views for that page on different dates.

Let's convert the data into a _tidy_ format:

1. Every column represents one variable
2. Every row represents one observations. 

Here, the true varaibles in this data are:

- Page name
- Language
- Date
- Number of Views

And a single observation is the number of page views recorded for a single page on a single day.

```{R}
# convert to long format. 
data <- data %>%
      gather(key = "date", value = "views", -article, -language, -domain)

tail(data)
```

Now, our dataframe of ~145,000 rows and ~800 columns has been reshaped to a dataframe of ~116,000,000 rows and 3 columns.

#### 1.3 Consolidating data types

The next step is to make sure each of the columns are of the right data type. 

```{R}
str(data)
```

`date` is a character which doesn't look right, to use it as a date we will have to remove the leading `X` character and convert the remaining to date. We also need to convert from character to date class but we are going to wait a bit before doing that.

```{R}
data <- data %>%
  mutate(date = str_replace(pattern = "X", replacement = "", date))
  
head(data)
```


#### 1.4 Missing values

Just so we're aware - how many values are missing? 


```{R}
sum(is.na(data$views)) / nrow(data) * 100
```

Around 7 percent of the view counts are missing. We can't be sure if this means that there were zero views for that page on that day, or if the view count data is simply missing for that day. 

## 2. Nesting `dataframes` - a `dataframe` for every page. 

Now, we transform the dataset into a dataframe such that every page + language populates one row, and the corresponding data is stored in a list column. This is a three-liner with the `tidyr::nest()` function. 

#### 2.1 Using the `tidyr::nest()` function.

**A word of warning** - creating list columns with the `tidyr::nest()` function is very slow  if one of your columns is of type `Date` (see [this Github issue for more details](https://github.com/tidyverse/tidyr/issues/369)). As such, I will first nest the dataframes, and then convert the `date` column in each nested dataframe (initially a `character` datatype) to a native date format. 

```{R}
# dataframes within dataframes
nested <-  data %>%
  group_by(article, language, domain) %>% 
  nest()
```

Now, taking a look at our nested dataframe, we can see that there is one row per Wikipedia page, and a column called `data` which is populated with a tibble (well behaved dataframe) containing the data fro that Wikipedia page:

```{R}
# first five wikipedia pages
head(nested)
```


```{R}
# isolating the first page in the dataset
first_page <- nested[1,]

# taking a look at the first entry fo the column `data`
first_page$data
```

```{r}
cast_date <- function(df){
      df %>% mutate(date = as.POSIXct(date, format = "%Y.%m.%d"))     
}
nested <- nested %>%
      mutate(data = map(.f = cast_date, .x = data))
```

```{R}
#https://www.kaggle.com/timib1203/managing-many-models-with-tidyr-purrr-and-broom
# remove the unnested data to free up some memory
rm(data)
```

## 3. Before we start modeling... what's the data look like? 

The point of this notebook is to show how to use modeling for data exploration. But even so - I can't jump into modeling without knowing what the data looks like at the least.

I'm most interested in identifying structure in the data that will influence my choices of parameters in models to come, or which models to use. For example, I'd be interested in identifying are any seasonal structure at a human interval - such as weekly or annual seasonality - which I've come to expect with any time series data relating to online activity. This is because if I choose to fit a Seasonal ARIMA model to each time series, or perform some sort of time series decomposition, I will need to know the periodicity of the seasonality, if any. I'd also be interested in identifying any outliers or extreme values. This may motivate me to transform my data in some way, or use models that are robust to extreme values. 

#### 3.1 A first glance

So far, our data consists of one row per Wikipedia page, with a column containing the data for each page:


```{R}
head(nested)
```

Each nested tibble (the data associated with a page) consists of the view count over the dates in the dataset:

```{R}
nested[1, "data"] %>%
      .[[1]] %>%
      head()
```

Some interesting questions are:

1. What information is stored in those convoluted page names?
2. What seasonality can we observe in the page views?
3. How variable are the page views across the different pages?
4. How many pages have very extreme page view counts? 


#### 3.2 Disecting the page names

Taking a closer look at a sample of 30 page names, we can see that there is a lot of information stored in those names...

```{R}
nested %>%
  ungroup() %>% 
  select(article) %>% 
  sample_n(30)
```

Some of the things I've noticed:

1. It looks like the the begining of the name is the Wikipedia page's title - spaces seperated by underscores. I see values of `Page` that start with strings.
2. After the article title, there is a two letter code for the language (_ja, de, fr, en_, etc), followed by a period. 
3. The end of the page name shows the client the views were made on (e.g. _mobile, web, all-access_)
4. The very last words of the page name (from this sample) are ither *all-agents* or *spider*. Not sure what this is. 
5. Different domains *wikimedia*, *wikipedia*, ...


```{R}
nested %>%
  group_by(language) %>% 
  summarise(n = n()) %>%
  mutate(freq = n / sum(n) * 100) %>% 
  filter(freq > 1) %>% 
  drop_na() %>% 
  ggplot(aes(x = language, y = sort(freq), fill = language)) +
  geom_col() +
  ylab("Proportion of pages with language") + 
  theme(legend.position = "")
```

Using this extraction method, we can see those languages with more than 1% of total pages (fo course, I did drop the NA):

1. German (de)
2. English (en)
3. French (fr)
4. Russian (ru)
5. Chinese (zh)

The remaining are other, we can classify now and make our lives easier.

```{R}
nested <- nested %>%
  ungroup() %>% 
  mutate(language = ifelse(
    language %in% c("de", "en", "fr", "ru", "zh", NA), language, "other"))
```


Now, extracting the domains by extracting the first character sequence that is surrounded by two periods:

```{R}
nested %>%
  group_by(domain) %>% 
  summarise(n = n()) %>%
  mutate(freq = n / sum(n) * 100)
```


```{R}
# a small sample of `Page` and `article` values
nested %>%
      sample_n(10) %>%
      select(article)
```

This seems to be working well. Now we can compare articles across different languages. 

#### 3.3 Getting a sense for seasonality

If there is clear seasonality in the data, it would be important to identify it early, as the periodicity is a hyperparameter for many time series models, such as `ARIMA` and State space models. Looking at the first time series in the `nested` dataframe as an example. We use a log-scale for the y-axis, we can see some more structure to mitigate the effect of large spikes.

```{R}
# isolate the first page
first_page = nested[1,]

# plot the series of the first page
first_page %>%
      .$data %>%
      .[[1]] %>%
      ggplot(aes(x = date, y = views, color = views)) + 
            geom_point() + 
            geom_line() + 
            scale_y_log10()
```


```{R}
# a function to plot a simple time series plot on a log scale for the y-axis 
plot_series_log <- function(df, title = NULL){
      df %>%
            ggplot(aes(x = date, y = views, color = views)) + 
            geom_point() + 
            geom_line() + 
            labs(title = paste(title, "series", sep = " ")) + 
            scale_y_log10() + 
            theme(legend.position = "")
}


first_page %>%
      .$data %>%
      .[[1]] %>%
      plot_series_log(title = first_page$article)
```


Again, it doesn't look like there is strong seasonality in this series. This could be an artifact of the particular series, however. This wikipedia page doesn't get very much traffic - and so a natural seasonal variation may not appear in this data. 

Perhaps looking at a more popular page will be more meaningful. To get a feel for how popular each page is, I'll store average, median, and standard deviation of the daily veiws for each page in the `nested` dataframe.

To do so without unnesting the nested data in `nested`, I'll use a higher order function, `extract_metric`. This function takes in a nested dataframe `d`, and a function used to calculalate a metric `metric`, and returns the that function applied to the `views` column of the nested dataset. I can then map this function with `metric` euqual to `mean`, `median` and `function(l) sqrt(var(l)` to get the average, median and standard deviation of of the `views` in each nested dataframe. 


```{R}
# apply an arbitrary metrix on the `views` column of of the nested data
extract_metric <- function(d, metric, ...){
      metric(d$views, ...)
}

# map this H.O.F to get the average, median and standard deviation of views
nested = nested %>% 
      mutate(average.views = map_dbl(.f = extract_metric, .x = data, metric = mean, na.rm = TRUE), 
             median.views = map_dbl(.f = extract_metric, .x = data, metric = median, na.rm = TRUE), 
             stddev.views = map_dbl(.f = extract_metric, .x = data, metric = function(l) sqrt(var(l, na.rm = TRUE))))

```


Now we have the mean, median and standard deviation of the views stored in `nested`.

```{R}
nested %>%
      ggplot(aes(x = average.views, fill = language)) + 
      geom_density(position = "stack") + 
      scale_x_log10() +
      xlab("Average daily views (log scale)")
```
```{R}
nested %>%
      ggplot(aes(x = median.views, fill = language)) + 
      geom_density(position = "stack") + 
      scale_x_log10() +
      xlab("Median daily views (log scale)")

```
```{R}
nested %>%
      ggplot(aes(x = stddev.views, fill = language)) + 
      geom_density(position = "stack") + 
      scale_x_log10() +
      xlab("Standard deviation of daily views (log scale)")
```


Now, arrnging the views in terms of decending average view count:


```{R}
nested %>%
      arrange(desc(average.views))
```


That's not surprising - the Wikipeda Main page gets the highest average daily view count. Perhaps this page will have more apparent seasonality. 


Two things here are interesting. First: we can indeed see some more regular seasonality in the main page. It looks like there is a periodicity of 7 days - presumably for the days of the week. 

The second interesting thing is that there is a hugh Spike in web vies for about a month starting in August 2016. What could this be? And more importanty, how can I detect similar spikes in the 145K other time series in this dataset? 

What this shows me is that some of the series have clear seasonality (e.g. the Wikipedia main page), while others do not (the first page in the nested dataframe). In this followin sections, I will try and use automatic modeling methods to help identify which series have strong seasonality, and which don't. 


## 4. Modeling linear trend


Now for the fun stuff - mapping models onto the nested data. As a first step, I will try and model the trend of the view count using simple linear regression. Then, looking at measures of model quality such as the $R^2$, I can see which series are well explained with a linear trend, and which have more complex changes in mean. 

To apply a linear model to each of the nested dataframes, I'll first design a function that takes in a dataframe, and applies simple linear regression onto it: 

```{R}
# a function for fitting SLR to an inptut dataframe
apply_lm <- function(df){
      lm(data = df, views ~ date)
}
```


Now, mapping this function onto each of the nested dataframes, we can get a new column, `linear_trend`, which stores linear models, fit onto each corresponding nested dataframe:


```{R}
# fit a linear model to each page
nested <-  nested %>%
      mutate(linear_trend = map(.f = apply_lm, .x = data))

# isolate the first page
first_page = nested[1,]
```


Now, along with a list column of the data for each page in a column, we also have a fitted linear model object stored in a seperate column for each wikipedia page:

```{R}
nested %>%
      head() %>%
      select(article, data, linear_trend)
```


For example, if we wanted to see the summary of the first linear model fit:


```{R}
nested[1,] %>% .$linear_trend %>% .[[1]] 
```


It'd be interesting to store a measure of model quality for each of these linear models - namely the $R^2$ statistic. This will be helpful, as looking at each model's $R^2$ will help us highlight which Wikipedia pages exhibit clear linear trend, and which don't (this might be hard to determine otherwise - can you think of a good way to do so?)


I'll define a function `extract_r2` - which uses the `broom` function to extract the $R^2$ of a linear model. I'll then map this function onto nested `lm` models to store the $R^2$ for each model:


```{R}
# a function for extracting only the R-squared statistics
extract_r2 <- function(model){
      glance(model)$r.squared
}

# map this function onto each model to store the R^2
nested <- nested %>%
      mutate(lm.r.squared = purrr::map_dbl(.f = extract_r2, .x = linear_trend))

```


Looking at the distribution of $R^2$ across the different Wikipedia pages:


```{R}
nested %>%
      ggplot(aes(x = lm.r.squared)) + 
      geom_density()
```


Most of the time series can not be explained well by a linear model, leading to low $R^2$. 

Some models have suspiciously high $R^2$ values - I suspect this is because most of the data is missing, and thus a linear model can fit these sparse data more effectively. To test this hypothesis, I can plot the model with the highest $R^2$:


```{R}
# a funtion for plotting a time series, with a fitted linear trend line on top of it
plot_linear_trend <- function(df, title){
      df %>%
            ggplot(aes(x = date, y = views, color = views)) +
            geom_point() + 
            geom_line() + 
            geom_smooth(method = "lm", se = FALSE) + 
            labs(title = title) + 
            theme(legend.position = "")
}
```
```{R}
# plot the model with the highest R^2
nested %>%
      arrange(desc(lm.r.squared)) %>%
      .[1,] %>%
      mutate(chart = map2(.f = plot_linear_trend, .x = data, .y = article)) %>%
      .$chart
```


Indeed - the model with the highest $R^2$ has only 2 non-missing points - which can be fitted perfectly by a line. 

But if we skip the pages with the 50 highest $R^2$ values, we can really see that these models have a roughly linear trend:


```{R}
nested %>%
      arrange(desc(lm.r.squared)) %>%
      filter(dplyr::between(row_number(), 50, 55)) %>%
      mutate(chart = purrr::map2(.f = plot_linear_trend, .x = data, .y = article)) %>%
      .$chart

```


Now, looking at the model with the lowest $R^2$:


```{R}
nested %>%
      arrange(lm.r.squared) %>%
      .[1,] %>%
       mutate(chart = purrr::map2(.f = plot_linear_trend, .x = data, .y = article)) %>%
      .$chart
```


We can see that this model as an $R^2$ of zero, as it's only a point - the model is underspecified, and so it cannot converge to an optimal linear fit (there are infinite straight lines that go through a point that are all equally valid regression lines). 

If we skip the 24 pages with the lowest $R^2$, we can see that some models have very low $R^2$ values not because the time seiries exhibit trend that is non-linear in nature, but rather because the series have few anamolous points. 

These anomolies lead to high residual error, decreasing the $R^2$. This is an interesting approach to identify outliers in the series': 


```{R}
nested %>%
      arrange(lm.r.squared) %>%
      filter(dplyr::between(row_number(), 25, 30)) %>%
      mutate(chart = purrr::map2(.f = plot_linear_trend, .x = data, .y = article)) %>%
      .$chart
```


Now, looking at plots of series which don't have extraordinarily high or low $R^2$ (to avoid series with mostly missing values), we find some series that truly exhibit non-linear trends, resulting in low $R^2$:


```{R}
nested %>%
      arrange(desc(lm.r.squared)) %>%
      filter(dplyr::between(row_number(), 10000, 10005)) %>%
      mutate(chart = purrr::map2(.f = plot_linear_trend, .x = data, .y = article)) %>%
      .$chart
```


## 5. Conclusion

In this notebook, I've experimented with list-columns and nested dataframes as an approach to apply modeling techniques in parallel onto many groups. Although this is a computationally expensive strategy, it is widely applicable - as in many cases one is interested in learning properties within groups, and then comparing these properties across groups. 

Using nested dataframes allows one to fit many models, and keep them all in one place in a tidy manner. This way, instead of keeping track of all the fitted models you have floating in your environment, you can work on one dataframe, and feel confident that you're not forgetting to apply operations to some of your datasets or models. 

I especially like to use this technique as a way of data exploration. I've shown how one can use fitted models applied to each group of a dataset to extract summary and model adequacy statistics, which can help an analyst learn about his/her data. This technique allows one to generate forecasts in parallel naturally, as well. 
